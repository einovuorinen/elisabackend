{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["SearchForm","props","className","onSubmit","search","onChange","getResultsbyChannel","channelData","map","channel","value","id","name","type","date","getResultsByDate","Display","f","filter","toLowerCase","displayData","item","includes","description","key","rightColumn","favorite","favorites","FavoriteButton","find","x","onClick","Filter","NavbarText","filterResults","Notification","message","App","useState","setchannel","setdate","programData","setProgramData","setFilter","channelKeys","setChannelKeys","livePrograms","setLivePrograms","localStorage","JSON","parse","setFavorites","notif","setNotification","channelsIsOpen","setChannelsIsOpen","searchIsOpen","setSearchIsOpen","liveIsOpen","setLiveIsOpen","favoritesIsOpen","setFavoritesIsOpen","useEffect","axios","get","then","response","data","console","log","event","a","preventDefault","post","setTimeout","concat","elem","setItem","stringify","Navbar","NavbarToggler","target","style","display","program","shortDescription","startTime","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.ad4d111a.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react'\nimport { Navbar, NavbarToggler, NavbarText } from 'reactstrap'\nimport axios from 'axios'\n\nconst SearchForm = (props) => {\n  return(\n    <div  className='belowNav'>\n    Search for a program\n    <form onSubmit={props.search} className='searchForm'>\n      channel: \n        <select onChange={props.getResultsbyChannel}>\n          {props.channelData.map(channel => <option value={channel.id}>{channel.name}</option>)}\n        </select>\n      date: <input type='date'\n        \tvalue={props.date}\n        \tonChange={props.getResultsByDate}\n    \t/>\n      <button type=\"submit\">Search</button>\n    </form>\n    </div>\n  )\n}\n\nconst Display = (props) => {\n  const f = props.filter.toLowerCase()\n  return (\n\t  <table className='table'>\n        {props.displayData.filter(item => (item.name && item.name.toLowerCase().includes(f)) || (item.description && item.description.toLowerCase().includes(f)))\n          .map(item => {\n            return (\n              <tr key={item.id}>\n                <td className='firstColumn'>{item.name}</td>\n                <td>{item.rightColumn}</td>\n                <td><FavoriteButton favorite={props.favorite} favorites={props.favorites} type={item.type} id={item.id}/></td>\n              </tr>)}\n          )}\n            </table>\n\t)\n}\n\nconst FavoriteButton = (props) => {\n  if (!props.favorites.find(x => x.id === props.id)) {\n    return <button className='favoriteButton' onClick={() => props.favorite(props.id, props.type)}>Favorite</button>\n  } else {\n    return <button className='favoriteButton' onClick={() => props.favorite(props.id, props.type)}>Remove from Favorites</button>\n  }\n}\n\nconst Filter = (props) => {\n\treturn (\n\t  <div>\n    \t<NavbarText>Keywords:</NavbarText><input \n        \tvalue={props.filter}\n        \tonChange={props.filterResults}\n    \t/>\n\t  </div>\n\t)\n}\n\nconst Notification = ({ message }) => {\n  if (message === null) {\n    return null\n  }\n  return (\n    <div className='alert alert-primary'>\n      {message}\n    </div>\n  )\n}\n\nconst App = () => {\n\n  const [channel, setchannel] = useState(37) // yle1 id as default\n  const [date, setdate] = useState('')\n  const [programData, setProgramData] = useState([])\n  const [filter, setFilter] = useState('')\n  const [channelKeys, setChannelKeys] = useState([])\n  const [livePrograms, setLivePrograms] = useState([])\n  const [favorites, setFavorites] = useState(localStorage.favorites ? JSON.parse(localStorage.favorites) : [])\n  const [notif, setNotification] = useState(null)\n\n  const [channelsIsOpen, setChannelsIsOpen] = useState(true)\n  const [searchIsOpen, setSearchIsOpen] = useState(false)\n  const [liveIsOpen, setLiveIsOpen] = useState(false)\n  const [favoritesIsOpen, setFavoritesIsOpen] = useState(false)\n\n  const toggleChannel = () => {\n    setSearchIsOpen(false)\n    setChannelsIsOpen(true)\n    setLiveIsOpen(false)\n    setFavoritesIsOpen(false)\n    setFilter('')\n  }\n  const toggleSearch = () => {\n    setSearchIsOpen(true)\n    setChannelsIsOpen(false)\n    setLiveIsOpen(false)\n    setFavoritesIsOpen(false)\n    setFilter('')\n  }\n  const toggleLive = () => {\n    setSearchIsOpen(false)\n    setChannelsIsOpen(false)\n    setLiveIsOpen(true)\n    setFavoritesIsOpen(false)\n    setFilter('')\n  }\n\n  const toggleFavorites = () => {\n    setSearchIsOpen(false)\n    setChannelsIsOpen(false)\n    setLiveIsOpen(false)\n    setFavoritesIsOpen(true)\n    setFilter('')\n  }\n\n  const hook = () => {\n    axios\n      .get('/channelnames')\n      .then(response => {\n        setChannelKeys(response.data)\n      })\n    axios\n      .get('/liveprograms')\n      .then(response => {\n        setLivePrograms(response.data)\n      })\n    console.log(livePrograms)\n  }\n  \n  useEffect(hook, [])\n\n  const getResultsbyChannel = (event) => {\n    setchannel(event.target.value)\n  }\n\n  const getResultsByDate = (event) => {\n    setdate(event.target.value)\n  }\n\n  const search = async (event) => {\n    event.preventDefault()\n    const response = await axios.post('/search', {channel: channel, date: date})\n    setProgramData(response.data)\n  }\n\n  const filterResults = (event) => {\n    setFilter(event.target.value)\n  }\n\n  const favorite = (id, type) => {\n    if (!favorites.find(x => x.id === id)) {\n      switch (type) {\n        case 'program':\n          setFavorites(favorites.concat(programData.find(elem => elem.id === id)))\n          break\n        case 'liveProgram':\n          setFavorites(favorites.concat(livePrograms.find(elem => elem.id === id)))\n          break\n        case 'channel':\n          setFavorites(favorites.concat(channelKeys.find(elem => elem.id === id)))\n          break\n        default: return\n      }\n      setNotification(`Added ${type} to favorites`)\n      setTimeout(() => {\n        setNotification(null)\n        }, 2500)\n    } else {\n      setFavorites(favorites.filter(item => item.id != id))\n      setNotification(`Removed ${type} from favorites`)\n      setTimeout(() => {\n        setNotification(null)\n        }, 2500)\n      return\n    }\n    localStorage.setItem('favorites', JSON.stringify(favorites))\n  }\n\n  return (\n    <div className='App'>\n      <Navbar className='dark'>\n        <NavbarToggler onClick={toggleChannel}>All Channels</NavbarToggler>\n        <NavbarToggler onClick={toggleSearch}>Search</NavbarToggler>\n        <NavbarToggler onClick={toggleLive}>Live Programs</NavbarToggler>\n        <NavbarToggler onClick={toggleFavorites}>Favorites</NavbarToggler>\n        <Filter\n          filter={filter}\n          filterResults={filterResults}\n        />\n      </Navbar>\n      <Notification message={notif}/>\n      <div style={{ display: searchIsOpen ? '' : 'none' }}>\n        <SearchForm\n          channelData={channelKeys}\n          channel={channel}\n          date={date}\n          getResultsbyChannel={getResultsbyChannel}\n          getResultsByDate={getResultsByDate}\n          search={search}\n        />\n        <Display\n          displayData={programData.map(program => {\n            return ({\n              type:'program',\n              id:program.id,\n              name:program.name,\n              description:program.shortDescription,\n              rightColumn:program.startTime\n            })\n          })}\n          filter={filter}\n          favorite={favorite}\n          favorites={favorites}\n        />\n      </div>\n      <div style={{ display: channelsIsOpen ? '' : 'none' }}>\n        <div className='belowNav'>These are all the available channels</div>\n        <Display\n          displayData={channelKeys.map(channel => {\n            return ({\n              type:'channel',\n              id:channel.id,\n              name:channel.name,\n              description:channel.description,\n              rightColumn:channel.id\n            })\n          })}\n          filter={filter}\n          favorite={favorite}\n          favorites={favorites}\n        />\n      </div>\n      <div style={{ display: liveIsOpen ? '' : 'none'}}>\n        <div className='belowNav'>These are currently live programs</div>\n        <Display\n          displayData={livePrograms.map(program => {\n            return ({\n              type:'liveProgram',\n              id:program.id,\n              name:program.name,\n              description:program.shortDescription,\n              rightColumn:program.startTime\n            })\n          })}\n          filter={filter}\n          favorite={favorite}\n          favorites={favorites}\n        />\n      </div>\n      <div style={{ display: favoritesIsOpen ? '' : 'none'}}>\n        <div className='belowNav'>These are your favorites</div>\n        <Display\n          displayData={favorites.map(item => {\n            return ({\n              type:'item',\n              id:item.id,\n              name:item.name,\n              description:item.shortDescription,\n              rightColumn:item.type\n            })\n          })}\n          filter={filter}\n          favorite={favorite}\n          favorites={favorites}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}